---
name: vibe-task-execution
description: "执行单个任务，强制遵循 TDD 顺序与任务清单依赖，包含变更记录与状态更新。用于实现阶段的任何代码改动。"
---

# 任务执行

## 核心流程

- 宣告："使用 vibe-task-execution 实现任务。"
- 读取 `requirements/<feature>/spec.md`、`requirements/<feature>/design.md`、`requirements/<feature>/review.md` 与 `requirements/<feature>/tasks.md`。
- 只能执行 `tasks.md` 中存在的任务编号，并按阶段顺序推进（初始化 → 基础能力 → 用户故事 → 收尾）。
- 未完成前置任务时，禁止执行后续任务。
- 用户故事任务必须先完成对应测试任务（TDD：红→绿→重构）；若测试任务未完成，直接切换执行测试任务，不再征询确认。
- 初始化/基础能力阶段不强制 TDD（与 spec-kit 对齐）。
- 对功能或修复必须遵循本文内嵌的 TDD 规则。
- 若 spec 含外部依赖（API/SDK/服务），任务需包含最小联通性测试与请求/响应日志记录，并在 `tasks.md` 与 `status.md` 标明路径。
- 遇到失败或异常必须遵循本文内嵌的系统化排障规则，并自动修复测试失败直到通过或明确阻塞原因。
- 仅在任务范围内实现，不额外添加功能。
- 将范围或设计变更记录到 `requirements/<feature>/changes.md`。
- 任务完成后在 `requirements/<feature>/tasks.md` 勾选，并更新 `requirements/<feature>/status.md`。
- 状态变更或任务完成后执行一次 git 提交（如仓库未初始化，先请求确认再初始化）。
- 宣称完成前必须遵循本文内嵌的完成前验证规则。
- 发现设计冲突时立即停止并请求确认。

## 内嵌规则：TDD（测试驱动开发）

### 概述

- 核心原则：写测试 → 观察失败 → 最小实现 → 通过 → 重构。
- 铁律：**没有失败的测试，不能写生产代码。**
- 例外仅在用户确认下（原型/生成代码/配置）。

### 红-绿-重构（强制顺序）

1. **RED**：写一个最小测试，明确单一行为。
2. **VERIFY RED**：运行测试并确认**确实失败**，错误原因是功能缺失而非拼写/环境问题。
3. **GREEN**：写最小实现让测试通过，不扩展功能。
4. **VERIFY GREEN**：同一测试与相关测试全部通过，输出无异常。
5. **REFACTOR**：仅在绿灯后重构，保持测试全绿。

### 好测试要求

- 单一行为、清晰命名。
- 尽量使用真实代码，必要时才使用 mock。
- 不测试 mock 本身，不测试实现细节。

### 反模式（必须避免）

- 先写实现再补测试。
- 测试一开始就通过。
- 只验证 mock 交互、忽略真实行为。
- 为测试添加生产代码中的“测试专用”方法。
- 不理解依赖就盲目 mock，或 mock 数据结构不完整。

### TDD 验证清单

- [ ] 每个新增/修改的行为都有测试
- [ ] 观察到测试失败再写实现
- [ ] 失败原因与预期一致
- [ ] 最小实现让测试变绿
- [ ] 所有相关测试仍通过
- [ ] 重构后保持全绿

### 卡住时的处理

- 不知道怎么测：先写理想 API 与断言，再回到实现。
- 测试太复杂：设计太复杂，先简化接口。
- mock 过多：降低耦合或用依赖注入。

## 内嵌规则：系统化排障

### 概述

- 核心原则：**未完成根因调查前，不提出修复方案。**
- 适用范围：测试失败、异常行为、性能/构建/集成问题。

### 四阶段

1. **根因调查**
   - 逐行阅读错误信息与堆栈。
   - 复现步骤与频率，能稳定复现才继续。
   - 检查最近变更（diff/配置/依赖）。
   - 多组件系统必须在边界加证据日志：输入、输出、配置与状态。
   - 追踪数据流：从错误点向上追溯来源。
2. **模式分析**
   - 找到相似的正常实现。
   - 列出所有差异，不假设无关。
   - 明确依赖与环境假设。
3. **假设与验证**
   - 一次只提出一个假设。
   - 做最小改动验证假设。
   - 未证实则回到调查，不叠加修复。
4. **实施修复**
   - 必须先写能复现问题的失败测试。
   - 只修根因，不做“顺手优化”。
   - 修复后验证同一测试与相关测试。
   - 若连续 3 次修复失败，停止并质疑架构，避免继续试错。

### 支撑技巧（简版）

- 根因追踪：沿调用链反向查找首次引入问题的输入，再在源头修复。
- 防御式校验：在入口/业务/环境/日志多层加校验，避免同类问题复发。
- 条件式等待：用条件轮询替代固定 sleep，减少时序不稳与脆弱测试。

### 红旗

- “先改一版看看”
- 多个改动一起上
- 没写失败测试就修
- 不理解原因就修
- 第 3 次修复仍失败还继续尝试

## 内嵌规则：完成前验证

### 概述

- 核心原则：**没有新鲜验证证据，不能宣称完成。**
- 铁律：**先验证，再宣称。**

### Gate Function

1. **IDENTIFY**：哪条命令能证明结论？
2. **RUN**：运行完整命令（本次会话内）。
3. **READ**：读取输出与退出码。
4. **VERIFY**：是否证明结论？
   - 否：修复 → 重新验证
   - 是：用证据表述结论

### 失败处理

- 验证失败立即进入系统化排障。
- 修复后必须重跑同一验证命令。

### 红旗

- 使用“应该/大概/看起来”
- 未验证就表达满意或完成
- 只跑部分测试或依赖旧输出
- 未验证就提交/切到下一任务
